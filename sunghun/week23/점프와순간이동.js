// 정확성  테스트
// 테스트 1 〉	통과 (0.03ms, 33.3MB)
// 테스트 2 〉	통과 (0.03ms, 33.4MB)
// 테스트 3 〉	통과 (0.03ms, 33.3MB)
// 테스트 4 〉	통과 (0.03ms, 33.4MB)
// 테스트 5 〉	통과 (0.03ms, 33.4MB)
// 테스트 6 〉	통과 (0.03ms, 33.5MB)
// 테스트 7 〉	통과 (0.04ms, 33.4MB)
// 테스트 8 〉	통과 (0.03ms, 33.4MB)
// 테스트 9 〉	통과 (0.03ms, 33.5MB)
// 테스트 10 〉	통과 (0.04ms, 33.4MB)
// 테스트 11 〉	통과 (0.03ms, 33.4MB)
// 테스트 12 〉	통과 (0.03ms, 33.4MB)
// 테스트 13 〉	통과 (0.03ms, 33.3MB)
// 테스트 14 〉	통과 (0.03ms, 33.4MB)
// 테스트 15 〉	통과 (0.03ms, 33.3MB)
// 테스트 16 〉	통과 (0.03ms, 33.4MB)
// 테스트 17 〉	통과 (0.03ms, 33.5MB)
// 테스트 18 〉	통과 (0.03ms, 33.5MB)
// 효율성  테스트
// 테스트 1 〉	통과 (0.03ms, 33.4MB)
// 테스트 2 〉	통과 (0.04ms, 33MB)
// 테스트 3 〉	통과 (0.05ms, 33MB)
// 테스트 4 〉	통과 (0.04ms, 32.9MB)
// 테스트 5 〉	통과 (0.05ms, 33.3MB)
// 테스트 6 〉	통과 (0.05ms, 33MB)
// 테스트 7 〉	통과 (0.03ms, 33.4MB)
// 테스트 8 〉	통과 (0.04ms, 33.4MB)
// 테스트 9 〉	통과 (0.03ms, 33.5MB)
// 테스트 10 〉	통과 (0.04ms, 33MB)

function solution(n)
{
    // 수트 기능 : 1. 한번에 K칸 앞으로 전진
    // 2. 순간이동 : 현재까지 온 거리 X 2
    // 건전지 -> 순간이동: 사용량 줄지 않음 // K칸 점프 : K 만큼 건지지 사용량 줄어듬
    // => 순간이동이 더 효율적
    
    // N : 가려고하는 거리
    
    // 일단 처음은 1칸은 사용량 1을 소모해서 이동해야 겠다.
    // 
    
    let ans = 0;
    
    while (n !== 0) {
        if (n % 2 === 1) {
            ans++;
            n -= 1;
        } else {
            n /= 2;
        }
    }

    return ans;
}