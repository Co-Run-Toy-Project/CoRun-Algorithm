// 정확성  테스트
// 테스트 1 〉	통과 (0.04ms, 33.6MB)
// 테스트 2 〉	통과 (0.06ms, 33.6MB)
// 테스트 3 〉	통과 (0.05ms, 33.5MB)
// 테스트 4 〉	통과 (0.04ms, 33.4MB)
// 테스트 5 〉	통과 (0.07ms, 33.5MB)
// 테스트 6 〉	통과 (0.05ms, 33.6MB)
// 테스트 7 〉	통과 (0.06ms, 33.5MB)
// 테스트 8 〉	통과 (0.11ms, 33.4MB)
// 테스트 9 〉	통과 (0.07ms, 33.6MB)
// 테스트 10 〉	통과 (0.08ms, 33.4MB)
// 테스트 11 〉	통과 (0.04ms, 33.4MB)
// 테스트 12 〉	통과 (0.07ms, 33.7MB)
// 테스트 13 〉	통과 (0.06ms, 33.5MB)
// 테스트 14 〉	통과 (0.08ms, 33.5MB)
// 효율성  테스트
// 테스트 1 〉	통과 (0.06ms, 33.1MB)
// 테스트 2 〉	통과 (0.06ms, 33MB)
// 테스트 3 〉	통과 (0.06ms, 33MB)
// 테스트 4 〉	통과 (0.04ms, 33.3MB)
// 테스트 5 〉	통과 (0.04ms, 33.3MB)
// 테스트 6 〉	통과 (0.06ms, 33.1MB)

// function solution(n) {
//     let data = [1, 2, 4]
//     let firstNum = Math.ceil(n / 3) - 1;
//     let lastNum = data[n % 3 - 1]
//     return lastNum;
// }

// 로직 이해중
function solution(n) {
    const stack = [];
    do{
        if(n % 3 === 0){ // 나머지가 0이면 나머지를 4로 바꿔주고 몫에서 -1.
            stack.push(4);
            n = Math.floor(n / 3) - 1;
        }else{
            // 나머지가 0이 아닌 경우 3진법으로 계산.
            stack.push(n % 3);
            n = Math.floor(n / 3);
        }
    }while(n > 0); 
    // n이 0보다 클때까지 반복. (n !== 0)는 유효성 5번 시간초과.

    return stack.reverse().join('');
    //stack = [1, 4] 이므로 뒤집어서 문자열로 변환 => return 값은 '41'
}