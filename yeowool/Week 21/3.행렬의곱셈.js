// [PGS] 행렬의 곱셈 / leve2
// 난이도 :  leve2
// 풀이시간 : 20 분
// 점수 : +6

/*
문제
2차원 행렬 arr1과 arr2를 입력받아, arr1에 arr2를 곱한 결과를 반환하는 함수, solution을 완성해주세요.

제한 조건
행렬 arr1, arr2의 행과 열의 길이는 2 이상 100 이하입니다.
행렬 arr1, arr2의 원소는 -10 이상 20 이하인 자연수입니다.
곱할 수 있는 배열만 주어집니다.
입출력 예
arr1	arr2	return
[[1, 4], [3, 2], [4, 1]]	[[3, 3], [3, 3]]	[[15, 15], [15, 15], [15, 15]]
[[2, 3, 2], [4, 2, 4], [3, 1, 4]]	[[5, 4, 3], [2, 4, 1], [3, 1, 1]]	[[22, 22, 11], [36, 28, 18], [29, 20, 14]]
/*
<의사코드>
배열과 배열을 곱하는거니까 for문을 통해서 차례대로 하나씩 곱해주면 되지 않을까?

1. arr1만큼의 이중배열 길이가 최종 return이 되니까 제일 바깥의 for문은 arr1의 길이만큼 돈다
2. answer은 이중배열이니까 처음에는 이중으로 선언했는데 다음 풀이에서 잘못됨을 인지, 바로 하나의 배열로 고침
3. 2차 배열의 갯수는 항상 두 배열이 모두 같으므로 arr1의 첫 번째 요소인 0번째 요소를 기준으로 길이를 측정하여 
   안쪽의 배열을 순회 할 수 있도록 한다
4. 그리고 마지막for문으로 arr2의 길이만큼 돈다
5. for문이 돌면서 두번째 for문에서 빈배열 arr에 곱해서 더한 값들을 push한 후에 result는 다시 0으로 만든다
6. 세 번째 for문에서 만들어진 1차배열을 answer에 push한 후에 arr를 다시 빈배열로 만든다
   for문이 다시 돌 때 초기값이여야하기 때문!
   어차피 들어간 값은 제일 바깥 for문에서 answer에 들어갔기 때문에 초기화 되어도 됨
7. for문이 끝나면 answer를 return

*/

function solution(arr1, arr2) {
  let answer = [[]];
  let result = 0;
  let arr = [];
  for (let i = 0; i < arr1.length; i++) {
    for (let j = 0; j < arr1[0].length; j++) {
      for (let k = 0; k < arr2.length; k++) {
        result = result + arr1[i][j] * arr2[j][k];
      }
      arr.push(result);
      result = 0;
    }
    answer.push(result);
    arr = [];
  }
  return answer;
}

/*
실패
 테스트 1
입력값 〉	[[1, 4], [3, 2], [4, 1]], [[3, 3], [3, 3]]
기댓값 〉	[[15, 15], [15, 15], [15, 15]]
실행 결과 〉	실행한 결괏값 [[],0,0,0]이 기댓값 [[15,15],[15,15],[15,15]]과 다릅니다.
테스트 2
입력값 〉	[[2, 3, 2], [4, 2, 4], [3, 1, 4]], [[5, 4, 3], [2, 4, 1], [3, 1, 1]]
기댓값 〉	[[22, 22, 11], [36, 28, 18], [29, 20, 14]]
실행 결과 〉	실행한 결괏값 [[],0,0,0]이 기댓값 [[22,22,11],[36,28,18],[29,20,14]]과 다릅니다.

push를 잘못했다
 */

function solution(arr1, arr2) {
  let answer = [];
  let result = 0;
  let arr = [];
  for (let i = 0; i < arr1.length; i++) {
    for (let j = 0; j < arr1[0].length; j++) {
      for (let k = 0; k < arr2.length; k++) {
        result = result + arr1[i][j] * arr2[j][k];
      }
      arr.push(result);
      result = 0;
    }
    answer.push(arr);
    arr = [];
  }
  return answer;
}

/*
실패
테스트 1
입력값 〉	[[1, 4], [3, 2], [4, 1]], [[3, 3], [3, 3]]
기댓값 〉	[[15, 15], [15, 15], [15, 15]]
실행 결과 〉	실행한 결괏값 [[6,24],[18,12],[24,6]]이 기댓값 [[15,15],[15,15],[15,15]]과 다릅니다.
테스트 2
입력값 〉	[[2, 3, 2], [4, 2, 4], [3, 1, 4]], [[5, 4, 3], [2, 4, 1], [3, 1, 1]]
기댓값 〉	[[22, 22, 11], [36, 28, 18], [29, 20, 14]]
실행 결과 〉	실행한 결괏값 [[24,21,10],[48,14,20],[36,7,20]]이 기댓값 [[22,22,11],[36,28,18],[29,20,14]]과 다릅니다.
 */

function solution(arr1, arr2) {
  let answer = [];
  let result = 0;
  let arr = [];
  for (let i = 0; i < arr1.length; i++) {
    for (let k = 0; k < arr2[0].length; k++) {
      for (let j = 0; j < arr2.length; j++) {
        result = result + arr1[i][j] * arr2[j][k];
      }
      arr.push(result);
      result = 0;
    }
    answer.push(arr);
    arr = [];
  }
  return answer;
}

/*

테스트 1 〉	통과 (3.22ms, 37MB)
테스트 2 〉	통과 (6.68ms, 39MB)
테스트 3 〉	통과 (4.94ms, 38.8MB)
테스트 4 〉	통과 (1.27ms, 33.9MB)
테스트 5 〉	통과 (4.49ms, 38.7MB)
테스트 6 〉	통과 (3.97ms, 38.5MB)
테스트 7 〉	통과 (0.65ms, 33.8MB)
테스트 8 〉	통과 (0.33ms, 33.6MB)
테스트 9 〉	통과 (0.28ms, 33.6MB)
테스트 10 〉	통과 (6.36ms, 38.8MB)
테스트 11 〉	통과 (3.25ms, 37MB)
테스트 12 〉	통과 (0.39ms, 33.8MB)
테스트 13 〉	통과 (4.10ms, 38.5MB)
테스트 14 〉	통과 (4.93ms, 38.8MB)
테스트 15 〉	통과 (3.53ms, 37.2MB)
테스트 16 〉	통과 (2.98ms, 38MB)
*/
