// [PGS] 귤 고르기 / leve2
// 난이도 :  level 2
// 풀이시간 :
// 점수 :

/*
경화는 과수원에서 귤을 수확했습니다. 경화는 수확한 귤 중 'k'개를 골라 상자 하나에 담아 판매하려고 합니다. 그런데 수확한 귤의 크기가 일정하지 않아 보기에 좋지 않다고 생각한 경화는 귤을 크기별로 분류했을 때 서로 다른 종류의 수를 최소화하고 싶습니다.

예를 들어, 경화가 수확한 귤 8개의 크기가 [1, 3, 2, 5, 4, 5, 2, 3] 이라고 합시다. 경화가 귤 6개를 판매하고 싶다면, 크기가 1, 4인 귤을 제외한 여섯 개의 귤을 상자에 담으면, 귤의 크기의 종류가 2, 3, 5로 총 3가지가 되며 이때가 서로 다른 종류가 최소일 때입니다.

경화가 한 상자에 담으려는 귤의 개수 k와 귤의 크기를 담은 배열 tangerine이 매개변수로 주어집니다. 경화가 귤 k개를 고를 때 크기가 서로 다른 종류의 수의 최솟값을 return 하도록 solution 함수를 작성해주세요.

제한사항
1 ≤ k ≤ tangerine의 길이 ≤ 100,000
1 ≤ tangerine의 원소 ≤ 10,000,000
입출력 예
k	tangerine	result
6	[1, 3, 2, 5, 4, 5, 2, 3]	3
4	[1, 3, 2, 5, 4, 5, 2, 3]	2
2	[1, 1, 1, 1, 2, 2, 2, 3]	1
입출력 예 설명
입출력 예 #1

본문에서 설명한 예시입니다.
입출력 예 #2

경화는 크기가 2인 귤 2개와 3인 귤 2개 또는 2인 귤 2개와 5인 귤 2개 또는 3인 귤 2개와 5인 귤 2개로 귤을 판매할 수 있습니다. 이때의 크기 종류는 2가지로 이 값이 최소가 됩니다.
입출력 예 #3

경화는 크기가 1인 귤 2개를 판매하거나 2인 귤 2개를 판매할 수 있습니다. 이때의 크기 종류는 1가지로, 이 값이 최소가 됩니다.
*/

/*
< 의사코드 >
k개를 팔려고 하는데
1개 이상 잇는 크기의 귤만 들어가기
큰 숫자부터 담기
1개만 있는 크기의 귤은 없개기
앞에서 6개만 잘라서 같은숫자 없애기?
*/

function solution(k, tangerine) {
  const obj = {};
  tangerine.forEach((n) => {
    obj[n] = ++obj[n] || 1;
  });
  console.log(obj);
  let sort = Object.values(obj).sort((a, b) => b - a);
  // let sort = tangerine.sort().reverse()
  // let box = []
  //     for(let i = 0; i < sort.length; i++) {
  //     if(sort[i] === sort[i+1]) {
  //         box.push(sort[i])
  //     }

  let sum = 0;
  //큰 수부터 체크
  let answer = 0;
  for (let num of sort) {
    answer++;
    sum += num;
    if (sum >= k) break;
  }
  console.log(sort);
  return answer;
}

// console.log(box)
// return box.length

/*
   테스트 1
입력값 〉	6, [1, 3, 2, 5, 4, 5, 2, 3]
기댓값 〉	3
실행 결과 〉	테스트를 통과하였습니다.
출력 〉	{ '1': 1, '2': 2, '3': 2, '4': 1, '5': 2 }
[ 2, 2, 2, 1, 1 ]
테스트 2
입력값 〉	4, [1, 3, 2, 5, 4, 5, 2, 3]
기댓값 〉	2
실행 결과 〉	테스트를 통과하였습니다.
출력 〉	{ '1': 1, '2': 2, '3': 2, '4': 1, '5': 2 }
[ 2, 2, 2, 1, 1 ]
테스트 3
입력값 〉	2, [1, 1, 1, 1, 2, 2, 2, 3]
기댓값 〉	1
실행 결과 〉	테스트를 통과하였습니다.
출력 〉	{ '1': 4, '2': 3, '3': 1 }
[ 4, 3, 1 ]
   */

/*
테스트 1 〉	통과 (3.10ms, 37.3MB)
테스트 2 〉	통과 (4.07ms, 38.3MB)
테스트 3 〉	통과 (3.01ms, 37MB)
테스트 4 〉	통과 (3.08ms, 37MB)
테스트 5 〉	통과 (3.91ms, 37.2MB)
테스트 6 〉	통과 (6.77ms, 38.3MB)
테스트 7 〉	통과 (3.15ms, 37.2MB)
테스트 8 〉	통과 (3.16ms, 37.1MB)
테스트 9 〉	통과 (3.12ms, 37.2MB)
테스트 10 〉	통과 (3.37ms, 37.2MB)
테스트 11 〉	통과 (0.19ms, 33.5MB)
테스트 12 〉	통과 (0.08ms, 33.3MB)
테스트 13 〉	통과 (0.13ms, 33.5MB)
테스트 14 〉	통과 (0.10ms, 33.5MB)
테스트 15 〉	통과 (0.09ms, 33.4MB)
테스트 16 〉	통과 (0.08ms, 33.4MB)
테스트 17 〉	통과 (0.12ms, 33.4MB)
테스트 18 〉	통과 (0.14ms, 33.4MB)
테스트 19 〉	통과 (0.11ms, 33.4MB)
테스트 20 〉	통과 (0.11ms, 33.4MB)
테스트 21 〉	통과 (0.28ms, 33.5MB)
테스트 22 〉	통과 (0.36ms, 33.5MB)
테스트 23 〉	통과 (0.39ms, 33.5MB)
테스트 24 〉	통과 (0.86ms, 33.8MB)
테스트 25 〉	통과 (3.86ms, 36.6MB)
테스트 26 〉	통과 (20.36ms, 41MB)
테스트 27 〉	통과 (115.36ms, 63.7MB)
테스트 28 〉	통과 (46.97ms, 46.7MB)
테스트 29 〉	통과 (75.01ms, 50.8MB)
테스트 30 〉	통과 (101.76ms, 63.8MB)
테스트 31 〉	통과 (19.32ms, 37.5MB)
테스트 32 〉	통과 (22.74ms, 37.8MB)
테스트 33 〉	통과 (93.66ms, 54MB)
테스트 34 〉	통과 (67.95ms, 50.9MB)
*/
