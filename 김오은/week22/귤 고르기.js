/**
 * 통과 여부 : 통과
 * 시간 : +3
 * 점수 : 50분
 */

/**
 *
 * @param {*} k 판매하고 싶은 귤 개수
 * @param {*} tangerine 귤 배열
 * @returns 서로 다른 종류의 수의 최솟값
 * 어떻게 개수 많은 순으로 sorting할까
 * 객체로 풀어볼까?
 */
function solution(k, tangerine) {
  let obj = {};

  // Set 안 쓰고 객체 추가해!
  tangerine.forEach((n) => {
    // obj[n] 값이 있으면 1을 더한 값을
    // obj[n] 값이 없으면 1을 넣어준다.
    obj[n] = ++obj[n] || 1;
  });

  // 2차원을 1차원으로 바꿔보자
  const arr = Object.values(obj).sort((a, b) => b - a);

  let cnt = 0; // 귤 개수
  let kind = 0; // 귤 종류
  for (let num of arr) {
    cnt += num;
    kind++; // 종류 추가
    if (cnt >= k) break;
  }

  return kind;
}

console.log(solution(6, [1, 3, 2, 5, 4, 5, 2, 3]));
// console.log(solution(4, [1, 3, 2, 5, 4, 5, 2, 3]));

/**
 * 3차 : 분기처리 추가
 * 테스트 1 〉	통과 (22.99ms, 38.7MB)
테스트 2 〉	통과 (12.24ms, 40.1MB)
테스트 3 〉	통과 (10.17ms, 38.5MB)
테스트 4 〉	통과 (8.22ms, 38.2MB)
테스트 5 〉	통과 (12.22ms, 38.2MB)
테스트 6 〉	통과 (18.34ms, 39.8MB)
테스트 7 〉	통과 (15.26ms, 38.6MB)
테스트 8 〉	통과 (10.02ms, 38.3MB)
테스트 9 〉	통과 (10.04ms, 38.5MB)
테스트 10 〉	통과 (13.58ms, 40MB)
테스트 11 〉	통과 (4.10ms, 33.6MB)
테스트 12 〉	통과 (3.02ms, 33.4MB)
테스트 13 〉	통과 (3.11ms, 33.5MB)
테스트 14 〉	통과 (3.01ms, 33.6MB)
테스트 15 〉	통과 (3.15ms, 33.5MB)
테스트 16 〉	통과 (3.19ms, 33.5MB)
테스트 17 〉	통과 (3.13ms, 33.5MB)
테스트 18 〉	통과 (3.19ms, 33.6MB)
테스트 19 〉	통과 (2.99ms, 33.5MB)
테스트 20 〉	통과 (3.25ms, 33.5MB)
테스트 21 〉	통과 (5.12ms, 34MB)
테스트 22 〉	통과 (7.02ms, 36.8MB)
테스트 23 〉	통과 (7.90ms, 37MB)
테스트 24 〉	통과 (9.69ms, 37.2MB)
테스트 25 〉	통과 (43.09ms, 41.3MB)
테스트 26 〉	통과 (754.09ms, 56.7MB)
테스트 27 〉	실패 (시간 초과)
테스트 28 〉	실패 (시간 초과)
테스트 29 〉	실패 (시간 초과)
테스트 30 〉	실패 (시간 초과)
테스트 31 〉	통과 (25.33ms, 38MB)
테스트 32 〉	통과 (51.98ms, 39.1MB)
테스트 33 〉	실패 (시간 초과)
테스트 34 〉	실패 (시간 초과)
 */

/**
 * 2차 set => 객체로 한 번에 처리했더니 시간복잡도 엄청 빨라짐
 * 테스트 1 〉	통과 (33.46ms, 38.6MB)
테스트 2 〉	통과 (27.94ms, 39.8MB)
테스트 3 〉	통과 (22.43ms, 38.6MB)
테스트 4 〉	통과 (13.92ms, 38.4MB)
테스트 5 〉	통과 (24.72ms, 38.6MB)
테스트 6 〉	통과 (27.60ms, 39.6MB)
테스트 7 〉	통과 (25.64ms, 38.6MB)
테스트 8 〉	통과 (24.86ms, 38.6MB)
테스트 9 〉	통과 (25.67ms, 38.6MB)
테스트 10 〉	통과 (26.46ms, 39.9MB)
테스트 11 〉	통과 (6.25ms, 33.6MB)
테스트 12 〉	통과 (3.00ms, 33.6MB)
테스트 13 〉	통과 (3.08ms, 33.6MB)
테스트 14 〉	통과 (3.41ms, 33.5MB)
테스트 15 〉	통과 (3.18ms, 33.5MB)
테스트 16 〉	통과 (3.01ms, 33.6MB)
테스트 17 〉	통과 (3.16ms, 33.6MB)
테스트 18 〉	통과 (3.10ms, 33.6MB)
테스트 19 〉	통과 (3.11ms, 33.5MB)
테스트 20 〉	통과 (3.49ms, 33.5MB)
테스트 21 〉	통과 (5.74ms, 34.3MB)
테스트 22 〉	통과 (15.31ms, 37.1MB)
테스트 23 〉	통과 (24.54ms, 37.2MB)
테스트 24 〉	통과 (43.29ms, 37.1MB)
테스트 25 〉	통과 (1236.61ms, 41.2MB)
테스트 26 〉	실패 (시간 초과)
테스트 27 〉	실패 (시간 초과)
테스트 28 〉	실패 (시간 초과)
테스트 29 〉	실패 (시간 초과)
테스트 30 〉	실패 (시간 초과)
테스트 31 〉	통과 (28.44ms, 38.4MB)
테스트 32 〉	통과 (452.91ms, 41.3MB)
테스트 33 〉	실패 (시간 초과)
테스트 34 〉	실패 (시간 초과)
 */

/**
 * 1차 시간 복잡도
 * 음 역시 이것저것 썼더니 답은 맞지만 장렬한 시간초과로군
 *
테스트 1 〉	통과 (1136.68ms, 43.3MB)
테스트 2 〉	통과 (1139.97ms, 43.3MB)
테스트 3 〉	통과 (927.09ms, 43.3MB)
테스트 4 〉	통과 (152.67ms, 41.8MB)
테스트 5 〉	통과 (1106.12ms, 44MB)
테스트 6 〉	통과 (1285.00ms, 43.5MB)
테스트 7 〉	통과 (1185.67ms, 42.3MB)
테스트 8 〉	통과 (1135.41ms, 42.3MB)
테스트 9 〉	통과 (1455.48ms, 43.4MB)
테스트 10 〉	통과 (1292.45ms, 42.3MB)
테스트 11 〉	통과 (0.61ms, 33.6MB)
테스트 12 〉	통과 (0.09ms, 33.5MB)
테스트 13 〉	통과 (0.13ms, 33.4MB)
테스트 14 〉	통과 (0.09ms, 33.5MB)
테스트 15 〉	통과 (0.12ms, 33.5MB)
테스트 16 〉	통과 (0.09ms, 33.5MB)
테스트 17 〉	통과 (0.22ms, 33.5MB)
테스트 18 〉	통과 (0.12ms, 33.4MB)
테스트 19 〉	통과 (0.09ms, 33.5MB)
테스트 20 〉	통과 (0.18ms, 33.4MB)
테스트 21 〉	통과 (3.34ms, 35.8MB)
테스트 22 〉	통과 (18.20ms, 36.7MB)
테스트 23 〉	통과 (26.52ms, 36.8MB)
테스트 24 〉	통과 (41.83ms, 36.6MB)
테스트 25 〉	통과 (2081.78ms, 39.6MB)
테스트 26 〉	실패 (시간 초과)
테스트 27 〉	실패 (시간 초과)
테스트 28 〉	실패 (시간 초과)
테스트 29 〉	실패 (시간 초과)
테스트 30 〉	실패 (시간 초과)
테스트 31 〉	통과 (246.17ms, 41.4MB)
테스트 32 〉	통과 (2563.81ms, 44.2MB)
테스트 33 〉	실패 (시간 초과)
테스트 34 〉	실패 (시간 초과)
 */

// function solution(k, tangerine) {
//   let obj = {};
//   // 중복 제거
//   let set = new Set(tangerine.sort());

//   // 키 추가
//   for (const key of set) {
//     // 배열에서 키값이랑 같으면 값으로 추가하기
//     obj[key] = tangerine.filter((el, idx) => el === key).length;
//   }

//   // 객체 값 순으로 정렬
//   // 참고 : https://kyounghwan01.github.io/blog/JS/JSbasic/object-sort/#object-entries-reduce%E1%84%85%E1%85%B3%E1%86%AF-%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB-%E1%84%87%E1%85%A1%E1%86%BC%E1%84%87%E1%85%A5%E1%86%B8
//   let arr = Object.entries(obj).sort(([, a], [, b]) => b - a);
//   let cnt = 0; // 귤 개수
//   let kind = 0; // 귤 종류
//   for (let i = 0; i < Object.keys(obj).length; i++) {
//     if (cnt < k) {
//       cnt += arr[i][1];
//       kind++; // 종류 추가
//     }
//   }
//   console.log(arr)
//   return kind;
// }
